# Head_First_Go
Вивчаємо програмування по книзі Head First Go (https://headfirstgo.com)

Всім читачам "ПРИВІТ" починаю свій шлях вивчення мови програмування Go! (20.01.2025) 
Всі прикладм, нотатки та свої думки буду викладати тут, по худу читання книги.

# 1. Знайомства з Go
Перша програма на Go (helloGo.go) була написана на веб-сайті https://paly.golang.org

    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, Go!")
    }

Пояснення:

    package main - Це рядок повідомляє, що весь код цього файлу відноситься до капету "main"
    import "fmt" - Означає, що ми будемо використовувати код форматованого тексту з пакета "fmt"
    func main() - Функція "main" відіграє важливу роль - саме вона виконується при запуску програми
    fmt.Println - Для цього вона викликає функцію "Println" з пакету "fmt"
    ("Hello, Go!") - Ця рядок виводить повідомлення "Hello, Go!" в терміналі

ВИКОРИСТАННЯ ФУНКЦІЙ З ДВОМА ПАКЕТАМИ

У файлі twoPackages.go описано як викликати два пакета, завдяки ().

    package main

    import (
        "math"
        "strings"
    )

    func main() {
        math.Floor(2.75)
        strings.Title("head first go")
    }

Пояснення:

    math.Floor(2.75) - викликаємо функцію Floor з пакету "math"
    strings.Title("head first go") - викликаємо функцію Title з пакету "strings"

Після того як пакети math та strings будут імпортовані, ми зможемо викликати функції Floor та Title. На даний час данний файл не дає нам ніяких результатів.

ПОВЕРНЕННЯ ЗНАЧЕНЬ ФУНКЦІЙ

returnFunctionValues.go

    package main

    import (
        "fmt"
        "math"
        "strings"
    )

    func main() {
        fmt.Println(math.Floor(2.75))
        fmt.Println(strings.Title("head first go"))
    }

byThePool.go "У басейна" це файл завдання з книги де потрібно заповнити прорущені слова коду щоб від дав результат "Cannonball!!!", використовуючи пропоновані фрагмети коду тільки один раз.

    package ____

    import (
        ____
    )

    ____ main() {
        fmt.Println(____)
    }

main, Println, "Connonball!!!", "math", "fmt", func.

СТРОКИ

Terms.go показує як можно користуватися аргументом Println

    \n - текст з нового рядка
    \t - символ табуляциї
    \" - двойні лабки
    \\ - зворотній "слеш"

РУНИ

runes.go руни в мові Go презентують окремі символи. Руні литерали записуються в одинарних кавичках ('). Для зберігання рун в мові Go використовується стандарт Юнікод (зберігаються у вигляді цифрового коду). 'A'-65, 'B'-66, 'Ж'-1174 ...

ТИПИ

Go використовує статичну типізацію - це означає, що типи всіх значень відомі ще до запуску програми. Функції очікують, що їх аргумент відноситься до конкретного типу, а їх повернення значення тоже має тип (який може співпадати чи не співпадати з типом аргумента). Якщо ви використали неправильний тип значення в неправильному місці Go повідомить вам про помилку.

Щоб дізнатися тип любого значення, передайте його функції TypeOf з пакету reflect (type.go).

    package main

    import (
        "fmt"
        "reflect"
    )

    func main() {
        fmt.Println(reflect.TypeOf(42))
        fmt.Println(reflect.TypeOf(3.1415))
        fmt.Println(reflect.TypeOf(true))
        fmt.Println(reflect.TypeOf("Hello, Go!!!"))
    }

Пояснення:

    reflect - імпортує пакет "reflect", щоб використати його функцію TypeOf

Типи які отримали в результаті (type.go) мають наступні значення:

    int - ціле число (не має дробової частини)
    float64 - число з крапкою. Тип використовується для зберігання чисел, які мають дробову частину. (Для зберігання використовується 64 біта данних, звідци суфікс 64).
    bool - логічне значення (true та false)
    string - рядок, почлідовність данних які зазвичай виглядають як символи тексту.

ОГОЛОШЕННЯ ЗМІННИХ

Змінна в Go уявляє собою область пам'яті в якій зберігаються значення. Щоб звертатися до змінної використовується оголошення зміної завдяки ключовому слову var, за я ким слідкує ім'я та тип значень які будут зберігатися в змінній. (declarationOfVariables.go)

    var quantity int
    var length, width float64
    var customerName string

Якщо значення змінної присвоюється одночасно з її оголошенням, тип змінної в оголошенні зазвичай не пишеться. Тип значення призначеної змінної, буде рахуватися типом цьої змінної.

    var quantity = 4
	var length, width = 1.2, 2.4
	var customerName = "Damon Cole"

НУЛЬОВЕ ЗНАЧЕННЯ

Якщо змінна оголошена без присвоєння значення, то вона буде мати нульове значення для даного типу. Для числових типів нульове значення = 0.

Для типів int та float64 нульове значення = 0, для bool нкльове значення = false, для типу string нульове значення = порожній рядок.

gameWithMagnets.go - це завдання з книги.

КОРОТКІ ОГОЛОШЕННЯ ЗМІННИХ

shortDeclarationOfVariables.go
Повний запис змінних:

    var quantity int = 4
	var length, width float64 = 1.2, 2.4
	var customerName string = "Damon Cole"

Короткий запис смінних:

    quantity := 4
	length, width := 1.2, 2.4
	customerName := "Damon Cole"

ПРАВИЛА ВИБОРУ ІМ'Я

В Go є один простий набір правил, використовуючий до ім'я змінної, функції та типу:

1.Ім'я має починатися з букви та може містити будь яку кількисть додаткових літер та чисел.

2.Якщо ім'я змінної, функції та типу починається з літери верхнього регистру, то воно рахується експортованим та може використовуватися в інших пакетах, крім донного. Якщо починається з нижнього регистру то воно рахується неекспортованим, такі імена доступні тільки в данному пакеті.

ПЕРЕТВОРЕННЯ

При виконаннмі матиметичної дії та операцій в Go значення мають відноситися до одного типу. Якщо типи відрізняються ви отримаєте повідомлення про помилкук.

    var quantity int = 4
	var length, width float64 = 1.2, 2.4
    fmt.Println(length*quantity)

Ця помилка вирішується перетворенням значення одного типу в інший.

    var myInt int = 2
    float64(myInt)

float64 - це тип до якого потрібно перетворити, а myInt - те що перетворюємо.
В результаті ми отримуємо нове значення потрібного типу. (transformation.go)

conversionExercise.go - завдання з книги по перетворенню.

ІНСТРУМЕНТИ GO

    go build - компілірує файл з вихідним кодом в двійковий файл
    go run - компілює та запускає програму без збередення у виконавчий файл
    go fmt - перетворює вихідний файл з використанням стандартів форматування Go

ЗАКІНЧЕННЯ 1 ГЛАВИ.

# 2. Який код буде виконуваться?

ВИКЛИК МЕТОДІВ

Методи в Go - це функції, зв'язані із значеннями конкретного типу.

Пакет strings має тип Replacer який щукає підрядок в рядку та заміняє кожне входження цьої підрядка в другому рядку. Іншими словами заміняє один сивол на інший, наприклад символ # буде замінений на букву "о" (symbolReplacement.go).

Функція strings.NewReplacer отримує аргумент - заміняє рядок ("#") та заміняє ("o") - поаертає значення strings.Replace.

NewReplacer повертає новий Replacer зі списку старого нового рядка пари. Заміни виконуються в тому порядку, в якому вони вказані в цільовий рядок без збігів, що перекриваються. Стара струна порівняння виконуються в порядку аргументів. 

ПЕРЕВІРКА РЕЗУЛЬТАТУ

В цій главі оглядається можливість Go для прийняття рішель про те чи потрібно виконувати блок коду чи ні.

Розглянимо ситуацію: Необхідно написати програму в якій студент вводе свій %  правильних відповідей і дфзнається чи здав він екзамен. Результат вираховується простою формулою: при значенні 60% і вище екзамен здан, а при знеченні нижче 60% - не зданий. 

Створюємо новий файл passFail.go для збереження прогорами.

Перж за все програма повинна отримувати від користувача %. Ми хочимо щоб користувач ввів число та натиснув Enter, а введене число зберіглося в змінній.

УМОВНІ КОМАНДИ

Умовні команди використовують логічні вирази (результат яких = true чи folse), щоб визначити чи має виконуватися код що міститься в них:

    if 1 == 1 {
        fmt.Println("I'll be printed!")
    }

    if 1 > 2 {
        fmt.Println("I won't!")
    }

    if 1 < 2 {
        fmt.Println("I'll be printed!")
    }

    if 1 >= 2 {
        fmt.Println("I won't!")
    }

    if 2 <= 2 {
        fmt.Println("I'll be printed!")
    }

    if 2 != 2 {
        fmt.Println("I won't!")
    }

Якщо код має виконуватися тільки тоді коли умова дає результат false, використовуйте ! - оператор логічного заперечення. Цей оператор бере значення true і перетворює його на false чи бере значення false та перетворює його на true.

        if !trie {
            fmt.Println("I won't be printed!")
        }

        if !false {
            fmt.Println("I will!")
        }

Якщо код має виконуватися тольки тоді коли обі умови правдиві, використовується опервтор && (і). А якщо вім моє виконуватися лище тоді коли правдива хочаби одна з двух умов, використовується оператор || (чи).

    if true && true {
        fmt.Println("i'll be printes!")
    }

    if true && false {
        fmt.Println("I won't!")
    }

    if false || true {
        fmt.Println("i'll be printes!")
    }

    if false || false {
        fmt.Println("I won't!")
    }

Вправа з книги conditionalCommands.go, fileSize.go

РЕПЕТВОРЕННЯ РЯДКІВ В ЧИСЛА

Умовні команди також можуть буди використані для перевірки введення даних.
Якщо ввседені дані будут відповідати вимогам, =< 60 то зміна status буде призначений рядок "passing" у іншому випадку "failing". (продовжуємо модифуківати файл passFail.go)

    func main() {
        fmt.Print("Enter a grade: ")
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil {
            log.Fatal(err)
        }
        if input >= 60 {
            status := "passing"
        } else {
            status := "failing"
        }
        fmt.Println(input)
    }

В даному випадку ми отримуємо помилку компіляциї, проблема в тому що input має тип string. Go може порівнювати числа з іншими числами, порівлювати число з рядком не вдається. А прямого перетворення типа рядка в число немає.

Потрібно буде вирішити дві проблеми: 1. В кінці рядку input знаходиться символ нового рядка, його потрібно видалити. 2. Інші символи рядка потрібно перетворити в число питу fload64.

В пакеті strings є функция TrimSpace, яка видаляє всі символи-пропуску (символ нового рядка, табуляция та звичайні пробіли) на початку та в кінці.

Таким чином потрібно передати TrimSpace, а затим знову призначити повернення значення змінної input

    input = strings.TrimSpace(input)

Після цього в рядку input моє залишитися тільки число, введене користувачем. Використаємо функцию ParseFloat з пакету strconv, щоб перетворити його в тип float64.

    grade, err := strconv.ParseFloat(input, 64)

Функция ParseFloat перетворює число в рядок і повертає його значення в форматі float64.

БЛОКИ

Завдання з книги (bloc.go)

Дефкі рядки цього коду приводят до помилки, тому що звертаються до змінної які знаходяться не в зоні видимісті.

    package main

    import "fmt"

    var a = "a"

    func main() {
        a = "a"
        b := "b"
        if true {
            c := "c"
            if true {
                d := "d"
                fmt.Println(a)
                fmt.Println(b)
                fmt.Println(c)
                fmt.Println(d)
            }
            fmt.Println(a)
            fmt.Println(b)
            fmt.Println(c)
            fmt.Println(d)
        }
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
    }

СТВОРЕННЯ ГРИ

Створює файл з назвою guess.go

Починаємо з генерування випадкових чисел від 1 до 100.

    package main

    import (
        "fmt"
        "math/rand"
    )

    func main() {
        target := rand.Intn(100) + 1
        fmt.Println(target)
    }

ЗАВЕРШЕННЯ 2 ГЛАВИ.

# 3. Виклик ФУНКЦІЙ

КОД ЩО ПОВТОРЮЄТЬСЯ

В данній граві буде розглянуто виклик функцій, ми навчимося оголошувати функції, створювати свої та викликати їх з значенням і без.

Уявіть що нам потрібно пофорбувати стіни, виробник вказав що 1 літру фарби вистачить на 10 квадратів. Нам потрібно порахувати скільки літрів фарби потрібно щоб пофарбувати кімнату. (dye.go)

    package main

    import "fmt"

    func main() {
        var width, heigth, area float64
        // Розрахунки для першої стіни
        width = 4.2
        heigth = 3.0
        area = width * heigth
        fmt.Println(area/10.0, "liters needed")
        // Розрахунки для другої стіни
        width = 5.2
        heigth = 3.5
        area = width * heigth
        fmt.Println(area/10.0, "liters needed")
    }

Таке рішення працює, але в нього є недоліки:

    1.Результат занадто точний, нам би вистачило пару цифр після крапки
    2.Використання повторення коду

В пакеті fmt є функция Printf - функция отримує рядок вставляє в нього одне або декілько значень, форматує заданим способом та виводе отриманий рядок.

    fmt,Printf("%0.2f\n", 1.0/3.0)

Функция Sprintf схожа на Printf але вона повертає форматований рядок, а не виводе його.

    resiltString := fmt.Sprintf("%0.2f\n", 1.0/3.0)
    fmt.Printf(resiltString)

ГРАГОЛИ ФОРМАТУВАННЯ (%)

Букви піся % визначають тип глагола

    %f - число з точко
    %d - ціле число
    %s - рядок
    %t - логічне значення (true чи false)
    %v - довільне значення
    %#v - довільне значення отформатоване в тому вигляді в якому відображається вв коді Go
    %T - тип переданого значення
    %% - знак проценту (літерал)

Значання ширини (widthValue.go)

